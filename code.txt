====./pipeline/qr_decode.py ====
import cv2
from pyzbar.pyzbar import decode


class QRCodeDecoder:
    """
    QRコード画像のデコードを扱うクラス。
    """

    def decode_from_path(self, qr_path: str) -> str or None:
        """
        指定された画像パスからQRコードを読み取り、デコードした文字列を返す。

        Args:
            qr_path (str): QRコード画像のパス。

        Returns:
            str or None: デコードされた文字列。読み取りに失敗した場合はNone。
        """
        # 画像を読み込む
        img = cv2.imread(qr_path)
        if img is None:
            print(f"エラー: 画像ファイル '{qr_path}' を読み込めません。")
            return None

        # QRコードをデコード
        decoded_objects = decode(img)

        # 検出されたオブジェクトがあれば、最初のものを返す
        if decoded_objects:
            # デコードされたデータはバイト形式なので、文字列に変換
            return decoded_objects[0].data.decode("utf-8")

        # 検出されたオブジェクトがなければNoneを返す
        return None

    def decode_from_path_from_image(self, img_data) -> str or None:
        """
        画像データ（numpy.ndarray）から直接QRコードをデコードする。
        """
        if img_data is None or img_data.size == 0:
            return None

        decoded_objects = decode(img_data)

        if decoded_objects:
            return decoded_objects[0].data.decode("utf-8")

        return None

====./pipeline/pipeline.py ====
import os
import json
import cv2
from pipeline.qr_enhancer import QREnhancer
from pipeline.qr_decode import QRCodeDecoder


class QRPipeline:
    def __init__(self, tobako_dir: str, raimu_dir: str, enhancer_params: dict = None):
        self.tobako_dir = tobako_dir
        self.raimu_dir = raimu_dir
        # enhancer_params を受け取れるように
        self.enhancer = QREnhancer(**(enhancer_params or {}))
        self.decoder = QRCodeDecoder()

    def run(self):
        evaluation_results = []
        if not os.path.exists(self.tobako_dir):
            print(
                f"エラー: 元の画像ディレクトリ '{self.tobako_dir}' が見つかりません。"
            )
            return
        if not os.path.exists(self.raimu_dir):
            os.makedirs(self.raimu_dir)
            print(f"新しいディレクトリ '{self.raimu_dir}' を作成しました。")

        # ファイル名をソートして処理順を保証
        sorted_files = sorted(
            os.listdir(self.tobako_dir), key=lambda x: int(os.path.splitext(x)[0])
        )

        for filename in sorted_files:
            if filename.endswith((".png", ".jpg", ".jpeg")):
                print(f"\n--- ファイル '{filename}' の処理を開始 ---")
                original_path = os.path.join(self.tobako_dir, filename)
                enhanced_path = os.path.join(self.raimu_dir, filename)

                # enhancer を適用
                enhanced_image = self.enhancer.binarize(original_path)
                if enhanced_image is not None:
                    cv2.imwrite(enhanced_path, enhanced_image)
                    print(f"鮮明化された画像を '{enhanced_path}' に保存しました。")
                else:
                    print(f"警告: '{original_path}' の処理に失敗しました。")
                    continue

                # デコード
                original_decode = self.decoder.decode_from_path(original_path)
                enhanced_decode = self.decoder.decode_from_path(enhanced_path)

                match = (original_decode is not None) and (
                    original_decode == enhanced_decode
                )

                result = {
                    "file": filename,
                    "toba": original_decode,
                    "raimu": enhanced_decode,
                    "match": match,
                }
                evaluation_results.append(result)
                print(f"デコード結果: {result}")

        # 結果をJSON保存
        evaluate_file_path = "evaluate.json"
        with open(evaluate_file_path, "w", encoding="utf-8") as f:
            json.dump(evaluation_results, f, indent=4, ensure_ascii=False)
        print(
            f"\nすべての処理が完了しました。評価結果は '{evaluate_file_path}' に保存されました。"
        )

====./pipeline/qr_enhancer.py ====
import cv2
import numpy as np


class QREnhancer:
    """
    QRコード画像を加工するクラス。
    現状は「モジュール単位の2値化」と「finder pattern の塗りつぶし」に特化。
    """

    def __init__(
        self, module: int = 33, white_thresh: int = 220, black_thresh: int = 50
    ):
        self.module = module
        self.white_thresh = white_thresh
        self.black_thresh = black_thresh

    def binarize(self, path: str) -> np.ndarray | None:
        img = cv2.imread(path, cv2.IMREAD_GRAYSCALE)
        if img is None:
            return None

        h, w = img.shape
        grid_size_x = w // self.module
        grid_size_y = h // self.module

        binary = np.ones_like(img, dtype=np.uint8) * 255  # 白で初期化

        for gy in range(self.module):
            for gx in range(self.module):
                x_start = gx * grid_size_x
                y_start = gy * grid_size_y
                x_end = (gx + 1) * grid_size_x if gx < self.module - 1 else w
                y_end = (gy + 1) * grid_size_y if gy < self.module - 1 else h

                cell = img[y_start:y_end, x_start:x_end]

                has_white = np.any(cell >= self.white_thresh)
                has_black = np.any(cell <= self.black_thresh)

                if has_white and not has_black:
                    value = 255
                elif has_black and not has_white:
                    value = 0
                elif has_white and has_black:
                    avg = np.mean(cell)
                    value = 255 if avg >= 128 else 0
                else:
                    avg = np.mean(cell)
                    value = 255 if avg >= 128 else 0

                binary[y_start:y_end, x_start:x_end] = value

        # finder pattern を強制的に黒に塗りつぶす
        binary = self._fill_finder_patterns(binary)

        return binary

    def _fill_finder_patterns(self, binary: np.ndarray) -> np.ndarray:
        """
        左上・右上・左下の finder pattern を正しい構造で塗りつぶす。
        外黒7×7 → 中白5×5 → 中央黒3×3。
        """
        h, w = binary.shape
        grid_size_x = w // self.module
        grid_size_y = h // self.module

        def draw_finder(x0, y0):
            # 7×7 黒枠
            binary[y0 : y0 + 7 * grid_size_y, x0 : x0 + 7 * grid_size_x] = 0
            # 内側 5×5 白
            binary[
                y0 + grid_size_y : y0 + 6 * grid_size_y,
                x0 + grid_size_x : x0 + 6 * grid_size_x,
            ] = 255
            # 中央 3×3 黒
            binary[
                y0 + 2 * grid_size_y : y0 + 5 * grid_size_y,
                x0 + 2 * grid_size_x : x0 + 5 * grid_size_x,
            ] = 0

        # 左上
        draw_finder(0, 0)
        # 右上
        draw_finder(w - 7 * grid_size_x, 0)
        # 左下
        draw_finder(0, h - 7 * grid_size_y)

        return binary

====./main.py ====
import sys
from pipeline.pipeline import QRPipeline
import evaluate.evaluate_pdf as evaluate_pdf
import evaluate.overlay_pdf as overlay_pdf
import evaluate.analysis_pdf as analysis_pdf


def run_pipeline():
    """
    QRコードの鮮明化とデコードのパイプラインを実行する関数。
    """
    tobako_dir = "qr_tobakosan"
    raimu_dir = "qr_raimu"

    params = {
        "module": 33,
        "white_thresh": 220,
        "black_thresh": 50,
    }

    pipeline_runner = QRPipeline(tobako_dir, raimu_dir, enhancer_params=params)
    pipeline_runner.run()


def run_evaluation():
    """
    評価レポート生成プロセスを実行する関数。
    """
    try:
        print("\n--- 評価レポートの生成を開始します ---")
        evaluate_pdf.main()
        overlay_pdf.main()
        analysis_pdf.main()
        print("--- 評価レポートの生成が完了しました ---")
    except FileNotFoundError:
        print("\nエラー: 評価に必要なファイルが見つかりません。")
        print("パイプラインを実行して、まずデータを生成してください。")


if __name__ == "__main__":
    print("\n--- QRコード評価システム ---")
    print("実行したい処理を選択してください:")
    print("1: QRコード鮮明化パイプラインの実行（データ生成）")
    print("2: 評価レポートの生成（PDF出力）")
    print("それ以外: 終了")

    user_input = input("選択肢の番号を入力してください: ")

    if user_input == "1":
        run_pipeline()
    elif user_input == "2":
        run_evaluation()
    else:
        print("システムを終了します。")
        sys.exit()

====./evaluate/evaluate_pdf.py ====
import os
import json
from fpdf import FPDF


class Evaluator:
    def __init__(self, json_path: str, tobako_dir: str, raimu_dir: str):
        self.json_path = json_path
        self.tobako_dir = tobako_dir
        self.raimu_dir = raimu_dir
        self.japanese_font_path = "ipaexg.ttf"

    def _create_pdf_report(self, evaluation_data: list):
        pdf = FPDF(orientation="P", unit="mm", format="A4")

        try:
            pdf.add_font("IPAexGothic", "", self.japanese_font_path, uni=True)
            pdf.set_font("IPAexGothic", "", 10)
        except Exception:
            pdf.set_font("helvetica", "", 10)

        pdf.add_page()

        # レイアウト設定
        pairs_per_row = 2
        img_w = 40
        img_h = 40
        margin_x = 15
        margin_y = 15
        pair_spacing_x = 90
        pair_spacing_y = 65
        gap_between_imgs = 5

        max_rows_per_page = int((297 - margin_y * 2) // pair_spacing_y)

        for idx, data in enumerate(evaluation_data):
            page_index = idx // (pairs_per_row * max_rows_per_page)
            pos_in_page = idx % (pairs_per_row * max_rows_per_page)

            row = pos_in_page // pairs_per_row
            col = pos_in_page % pairs_per_row

            if pos_in_page == 0 and idx > 0:
                pdf.add_page()

            x = margin_x + col * pair_spacing_x
            y = margin_y + row * pair_spacing_y

            filename = data["file"]
            file_number = os.path.splitext(filename)[0]

            original_path = os.path.join(self.tobako_dir, filename)
            enhanced_path = os.path.join(self.raimu_dir, filename)

            if os.path.exists(original_path):
                pdf.image(original_path, x=x, y=y, w=img_w, h=img_h)
            if os.path.exists(enhanced_path):
                pdf.image(
                    enhanced_path, x=x + img_w + gap_between_imgs, y=y, w=img_w, h=img_h
                )

            decode_text = data.get("raimu", "") or data.get("toba", "")
            decode_text = " ".join(decode_text.split())
            text = f"No.{file_number} De.{decode_text}"

            pdf.set_xy(x, y + img_h + 5)
            pdf.cell(img_w * 2 + gap_between_imgs, 8, text, align="C")

        pdf.output("evaluate/evaluation_report.pdf")
        print("評価レポートが 'evaluate/evaluation_report.pdf' に保存されました。")

    def run(self):
        try:
            with open(self.json_path, "r", encoding="utf-8") as f:
                evaluation_data = json.load(f)
        except FileNotFoundError:
            print(f"エラー: '{self.json_path}' が見つかりません。")
            return

        self._create_pdf_report(evaluation_data)


# --- ここを追加 ---
def main():
    evaluator = Evaluator(
        json_path="evaluate.json",
        tobako_dir="qr_tobakosan",
        raimu_dir="qr_raimu",
    )
    evaluator.run()


if __name__ == "__main__":
    main()

====./evaluate/overlay_pdf.py ====
import os
import json
import cv2
import numpy as np
from fpdf import FPDF
import tempfile


class Evaluator:
    def __init__(self, json_path: str, tobako_dir: str, raimu_dir: str):
        self.json_path = json_path
        self.tobako_dir = tobako_dir
        self.raimu_dir = raimu_dir
        self.japanese_font_path = "ipaexg.ttf"

    def _overlay_images(self, path1, path2):
        """QRの黒部分をグラデーションで色付けして重ね合わせる"""
        img1 = cv2.imread(path1, cv2.IMREAD_GRAYSCALE)
        img2 = cv2.imread(path2, cv2.IMREAD_GRAYSCALE)

        if img1 is None or img2 is None:
            return None

        # サイズを合わせる
        h = min(img1.shape[0], img2.shape[0])
        w = min(img1.shape[1], img2.shape[1])
        img1 = cv2.resize(img1, (w, h))
        img2 = cv2.resize(img2, (w, h))

        # 背景除去: 白(>=250)は透明扱い
        mask1 = img1 < 250
        mask2 = img2 < 250

        # toba (黄色系に着色) → 明るい部分は薄く、暗い部分は濃く
        toba_color = np.zeros((h, w, 3), dtype=np.uint8)
        toba_color[..., 0] = 0  # B
        toba_color[..., 1] = img1  # G (元の濃さを反映)
        toba_color[..., 2] = img1 // 2  # R (少し抑える)
        toba_color[~mask1] = (255, 255, 255)  # 背景は白

        # raimu (青系に着色)
        raimu_color = np.zeros((h, w, 3), dtype=np.uint8)
        raimu_color[..., 0] = img2  # B
        raimu_color[..., 1] = img2 // 2  # G
        raimu_color[..., 2] = 0  # R
        raimu_color[~mask2] = (255, 255, 255)

        # 半透明で重ねる
        overlay = cv2.addWeighted(toba_color, 0.5, raimu_color, 0.5, 0)

        return overlay

    def _create_pdf_report(self, evaluation_data: list):
        pdf = FPDF(orientation="P", unit="mm", format="A4")

        try:
            pdf.add_font("IPAexGothic", "", self.japanese_font_path, uni=True)
            pdf.set_font("IPAexGothic", "", 10)
        except Exception:
            pdf.set_font("helvetica", "", 10)

        pdf.add_page()

        pairs_per_row = 2
        img_w = 60
        img_h = 60
        margin_x = 15
        margin_y = 15
        pair_spacing_x = 90
        pair_spacing_y = 80

        max_rows_per_page = int((297 - margin_y * 2) // pair_spacing_y)

        for idx, data in enumerate(evaluation_data):
            page_index = idx // (pairs_per_row * max_rows_per_page)
            pos_in_page = idx % (pairs_per_row * max_rows_per_page)

            row = pos_in_page // pairs_per_row
            col = pos_in_page % pairs_per_row

            if pos_in_page == 0 and idx > 0:
                pdf.add_page()

            x = margin_x + col * pair_spacing_x
            y = margin_y + row * pair_spacing_y

            filename = data["file"]
            file_number = os.path.splitext(filename)[0]

            original_path = os.path.join(self.tobako_dir, filename)
            enhanced_path = os.path.join(self.raimu_dir, filename)

            overlay = self._overlay_images(original_path, enhanced_path)
            if overlay is not None:
                with tempfile.NamedTemporaryFile(
                    suffix=".png", delete=False
                ) as tmpfile:
                    tmp_path = tmpfile.name
                    cv2.imwrite(tmp_path, overlay)
                    pdf.image(tmp_path, x=x, y=y, w=img_w, h=img_h)
                    os.remove(tmp_path)

            decode_text = data.get("raimu", "") or data.get("toba", "")
            text = f"No.{file_number} de.{decode_text}"

            pdf.set_xy(x, y + img_h + 2)
            pdf.cell(img_w, 8, text, align="C")

        pdf.output("evaluate/overlay_report.pdf")
        print(
            "オーバーレイ評価レポートが 'evaluate/overlay_report.pdf' に保存されました。"
        )

    def run(self):
        try:
            with open(self.json_path, "r", encoding="utf-8") as f:
                evaluation_data = json.load(f)
        except FileNotFoundError:
            print(f"エラー: '{self.json_path}' が見つかりません。")
            return

        self._create_pdf_report(evaluation_data)


def main():
    evaluator = Evaluator(
        json_path="evaluate.json",
        tobako_dir="qr_tobakosan",
        raimu_dir="qr_raimu",
    )
    evaluator.run()


if __name__ == "__main__":
    main()

====./evaluate/analysis_pdf.py ====
import os
import json
import cv2
import textwrap
import matplotlib.pyplot as plt
from matplotlib.gridspec import GridSpec
from matplotlib.backends.backend_pdf import PdfPages
from matplotlib.patches import Rectangle
import matplotlib.patches as mpatches


class QRAnalysisReport:
    def __init__(
        self,
        json_path="evaluate.json",
        tobako_dir="qr_tobakosan",
        raimu_dir="qr_raimu",
        wrap_width: int = 40,
        bg_color: str = "#ffffff",  # 背景色（白）
        panel_color: str = "#f5f5f5",  # 情報パネル背景（薄グレー）
    ):
        self.json_path = json_path
        self.tobako_dir = tobako_dir
        self.raimu_dir = raimu_dir
        self.wrap_width = wrap_width
        self.bg_color = bg_color
        self.panel_color = panel_color

    def _wrap(self, s: str):
        if s is None:
            return "None"
        s = str(s).strip()
        # 半角スペースを削除
        s = s.replace(" ", "")

        return (
            "\n".join(textwrap.wrap(s, self.wrap_width))
            if len(s) > self.wrap_width
            else s
        )

    def _create_info_panel(self, ax, data, filename):
        """最小限に整えた情報パネル（読みやすさ重視）"""
        ax.axis("off")
        ax.set_facecolor(self.bg_color)

        # パネル領域（カード）
        margin = 0.03
        px, py = margin, margin
        pw, ph = 1 - 2 * margin, 1 - 2 * margin
        panel = Rectangle(
            (px, py),
            pw,
            ph,
            transform=ax.transAxes,
            facecolor=self.panel_color,
            edgecolor="#1a1f25",
            linewidth=1,
        )
        ax.add_patch(panel)

        # テキストカラー（ライト背景向け）
        title_color = "#111111"
        label_color = "#101824"
        value_color = "#0b0b0b"
        mono = "monospace"

        # ヘッダ: ファイル名（左上）
        file_number = os.path.splitext(filename)[0]
        ax.text(
            px + 0.03,
            py + ph - 0.06,
            f"#{file_number}.png",
            transform=ax.transAxes,
            fontsize=13,
            fontweight="bold",
            ha="left",
            color=title_color,
            bbox=dict(boxstyle="round,pad=0.1", fc="#ffffff", ec="none"),
        )

        # セクション表示（縦余白を広めに）
        start_y = py + ph - 0.14
        section_gap = 0.20

        # TOBA RESULT
        toba_text = self._wrap(data.get("toba", "None"))
        ax.text(
            px + 0.03,
            start_y,
            "TOBA RESULT",
            transform=ax.transAxes,
            fontsize=9,
            fontweight="bold",
            color=label_color,
            va="top",
        )
        ax.text(
            px + 0.03,
            start_y - 0.035,
            toba_text,
            transform=ax.transAxes,
            fontsize=9,
            color=value_color,
            va="top",
            family=mono,
        )

        # RAIMU RESULT (下へ余白をとる)
        raimu_y = start_y - section_gap
        raimu_text = self._wrap(data.get("raimu", "None"))
        ax.text(
            px + 0.03,
            raimu_y,
            "RAIMU RESULT",
            transform=ax.transAxes,
            fontsize=9,
            fontweight="bold",
            color=label_color,
            va="top",
        )
        ax.text(
            px + 0.03,
            raimu_y - 0.035,
            raimu_text,
            transform=ax.transAxes,
            fontsize=9,
            color=value_color,
            va="top",
            family=mono,
        )
        # MATCHステータスをRAIMU RESULTの下に配置
        match_flag = data.get("match", False)
        match_face = "#16a34a" if match_flag else "#ef4444"
        ax.text(
            px + 0.03,
            raimu_y - 0.08,
            f"MATCH: {match_flag}",
            transform=ax.transAxes,
            fontsize=9,
            fontweight="bold",
            color=match_face,
            va="top",
        )

        # メタデータ（任意、小さく表示）
        meta = data.get("optimal_params", {})
        if meta:
            meta_y = raimu_y - section_gap - 0.05
            ax.text(
                px + 0.03,
                meta_y,
                "OPTIMAL PARAMS",
                transform=ax.transAxes,
                fontsize=9,
                fontweight="bold",
                color=label_color,
                va="top",
            )
            # パラメータをkey: value形式で表示
            cur_y = meta_y - 0.035
            params_text = self._wrap(json.dumps(meta))
            ax.text(
                px + 0.03,
                cur_y,
                params_text,
                transform=ax.transAxes,
                fontsize=8,
                color=value_color,
                va="top",
                family=mono,
            )

    def generate_pdf(self, output_path="evaluate/analysis_repost.pdf"):
        # JSONロード
        if not os.path.exists(self.json_path):
            raise FileNotFoundError(f"JSON file not found: {self.json_path}")

        with open(self.json_path, "r", encoding="utf-8") as f:
            evaluation_data = json.load(f)

        # 軽い（白背景）スタイル
        plt.style.use("default")

        with PdfPages(output_path) as pdf:
            for data in evaluation_data:
                filename = data.get("file")
                if not filename:
                    continue

                original_path = os.path.join(self.tobako_dir, filename)
                enhanced_path = os.path.join(self.raimu_dir, filename)

                fig = plt.figure(figsize=(12, 4), facecolor=self.bg_color)
                gs = GridSpec(1, 3, figure=fig, width_ratios=[1, 1, 0.9], wspace=0.25)

                # 左: ORIGINAL
                ax1 = fig.add_subplot(gs[0, 0])
                ax1.set_facecolor(self.bg_color)
                if os.path.exists(original_path):
                    img1 = cv2.imread(original_path)
                    if img1 is not None:
                        img1 = cv2.cvtColor(img1, cv2.COLOR_BGR2RGB)
                        ax1.imshow(img1)
                ax1.axis("off")
                ax1.set_title(
                    "ORIGINAL (Toba)", fontsize=11, fontweight="bold", color="#111111"
                )

                # 中央: ENHANCED
                ax2 = fig.add_subplot(gs[0, 1])
                ax2.set_facecolor(self.bg_color)
                if os.path.exists(enhanced_path):
                    img2 = cv2.imread(enhanced_path)
                    if img2 is not None:
                        img2 = cv2.cvtColor(img2, cv2.COLOR_BGR2RGB)
                        ax2.imshow(img2)
                ax2.axis("off")
                ax2.set_title(
                    "ENHANCED (Raimu)", fontsize=11, fontweight="bold", color="#111111"
                )

                # 右: INFO PANEL
                ax3 = fig.add_subplot(gs[0, 2])
                self._create_info_panel(ax3, data, filename)

                plt.tight_layout()
                pdf.savefig(fig, dpi=150, facecolor=fig.get_facecolor())
                plt.close(fig)

        print(f"analysis PDF saved to '{output_path}'")


def main():
    # 必要に応じてパスを調整してください
    report = QRAnalysisReport(
        json_path="evaluate.json",
        tobako_dir="qr_tobakosan",
        raimu_dir="qr_raimu",
        wrap_width=36,
        bg_color="#ffffff",
        panel_color="#fefefe",
    )
    report.generate_pdf("evaluate/analysis_report.pdf")


if __name__ == "__main__":
    main()

